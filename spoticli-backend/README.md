# spoticli-backend

This backend provides an API for downloading and streaming music.

For streaming, a naive approach is to segment an MP3 file randomly. This won't work though because mp3 decoders normally require a mp3 header for decoding. And even adding a fake header to randomly segmented partitions will not work because the frame header contains information that may be exclusive to a given frame.

The approach I ended up devising, was to partition each frame at the frame boundaries. Then when data is sent, a cluster of frames are merged into a byte array sent.

This means that I first decode the ID3v2 tag, so I can remove it. Then I decode each frame's header to get the frame's size. I can then use this information to move to the start of thg next frame. I repeat this until no frames are left.

The anatomy of an mp3 is as shown below,
```
+---------------------+
|   MP3 File Header   |  --> Metadata (e.g., ID3v2 tags)
+---------------------+
|    Audio Frame 1    |  --> Contains header + data
+---------------------+
|    Audio Frame 2    |
+---------------------+
|    Audio Frame 3    |
+---------------------+
|    Audio Frame N    |  --> Last audio frame
+---------------------+
|  Optional Metadata  |  --> Footer (e.g., ID3v1 tags)
+---------------------+
```
In my algorithm, I strip the initial ID3v2 tag, then break the file apart by frames, as shown below,
```
+-------------------+   +-------------------+   +-------------------+   +-------------------+
| Frame 1 Header    |   | Frame 2 Header    |   | Frame 3 Header    |   | Frame N Header    |
+-------------------+   +-------------------+   +-------------------+   +-------------------+
| Frame 1 Data      |   | Frame 2 Data      |   | Frame 3 Data      |   | Frame N Data      |
+-------------------+   +-------------------+   +-------------------+   +-------------------+
    |                     |                     |                      |
(1152 samples)      (1152 samples)      (1152 samples)      (1152 samples)  
```
The frame slices are then grouped together, such that there is x frames per cluster. The size calculations required for this technique can be found in the [Decoder service](https://github.com/matttm/spoticli/blob/main/spoticli-backend/internal/services/decoder.go).

Also a feature of this backend is when doing a range request, only the start position is respected.

[Reference of file structure](https://www.codeproject.com/Articles/8295/MPEG-Audio-Frame-Header#MPEGAudioFrameHeader)

[ID3v2 Spec](https://mutagen-specs.readthedocs.io/en/latest/id3/id3v2.4.0-structure.html)

[MP3 frame anatomy](http://www.mp3-tech.org/programmer/frame_header.html)

[MP3 Decoder](https://www.diva-portal.org/smash/get/diva2:830195/FULLTEXT01.pdf)

## Project Structure

```
spoticli-backend/
â”œâ”€â”€ internal/
â”‚   â”œâ”€â”€ constants/       # HTTP and database table constants
â”‚   â”œâ”€â”€ controllers/     # HTTP request handlers
â”‚   â”œâ”€â”€ database/        # Database initialization and queries
â”‚   â”œâ”€â”€ routers/         # API route definitions
â”‚   â”œâ”€â”€ services/        # Business logic (audio processing, storage, caching)
â”‚   â””â”€â”€ utilities/       # Helper functions and utilities
â”œâ”€â”€ postman/            # Postman collections for API testing
â”œâ”€â”€ main.go             # Application entry point
â”œâ”€â”€ docker-compose.yml  # Multi-container Docker setup
â””â”€â”€ init.sql           # Database initialization script
```

## Getting Started

### Prerequisites
- Docker and Docker Compose
- Go 1.21+ (for local development)
- AWS credentials (or use LocalStack for local S3)

### Running with Docker Compose (Recommended)

The easiest way to run the entire stack is with Docker Compose, which sets up the app, MySQL database, and LocalStack (for S3 emulation):

```bash
# Set required AWS credentials (or use defaults for LocalStack)
export AWS_ACCESS_KEY_ID="your-key"
export AWS_SECRET_ACCESS_KEY="your-secret"
export AWS_REGION="us-east-1"

# Start all services
docker-compose up -d

# Check logs
docker-compose logs -f app
```

The application will be available at `http://localhost:4200`.

**Note:** To use presigned URLs with LocalStack, you'll need to map `localstack` to `127.0.0.1` in your hosts file:
```bash
echo "127.0.0.1 localstack" | sudo tee -a /etc/hosts
```
This is necessary because presigned URLs generated by LocalStack use the container name `localstack` as the hostname.

The `assets` directory in this project's root contains a sample mp3 file `sources_000.mp3` to test with.

### Running Locally (Development)

For local development without Docker:

1. **Set environment variables:**
```bash
# Processing variables
export STREAM_SEGMENT_SIZE=1000000
export FRAME_CLUSTER_SIZE=30

# Database connection
export DB_HOST="localhost"
export DB_PORT="3306"
export DB_USERNAME="ADMIN"
export DB_PASSWORD="ADMIN"

# AWS variables (use LocalStack endpoint for local development)
export AWS_ACCESS_KEY_ID="test"
export AWS_SECRET_ACCESS_KEY="test"
export AWS_REGION="us-east-1"
export AWS_ENDPOINT_URL="http://localhost:4566"
```

2. **Start the database:**
```bash
docker-compose up -d db localstack
```

3. **Build and run the backend:**
```bash
go build
./spoticli-backend
```

## API Endpoints

**ðŸ“‹ Complete API Schema:** The full API specification is available in [openapi.yml](openapi.yml) following the OpenAPI 3.0.3 standard. You can import this file into tools like [Swagger UI](https://editor.swagger.io/), Postman, or any OpenAPI-compatible client for interactive documentation and testing.

### Health Check
- `GET /` - Returns service health status

### Audio Endpoints
- `GET /audio/{id}` - Get presigned S3 URL for audio file
- `GET /audio/proxy/{id}` - Download complete audio file through backend proxy
- `GET /audio/proxy/stream/{id}` - Stream audio file in chunks (supports range requests)
- `POST /audio` - Upload audio file via presigned URL

### File Metadata Endpoints
- `GET /files/{cd}` - Get all files of a specific content type

### Example Requests

**Upload a file:**
```bash
curl -X POST http://localhost:4200/audio \
  -H "Content-Type: application/json" \
  -d '{"filename": "song.mp3"}'
```

**Stream audio:**
```bash
curl -H "Range: bytes=0-" http://localhost:4200/audio/proxy/stream/1 --output song.mp3
```

## Configuration

Key environment variables:

| Variable | Description | Default |
|----------|-------------|---------|
| `STREAM_SEGMENT_SIZE` | Size of streaming segments in bytes | 1000000 |
| `FRAME_CLUSTER_SIZE` | Number of MP3 frames per cluster | 30 (600 in Docker) |
| `DB_HOST` | MySQL host | localhost |
| `DB_PORT` | MySQL port | 3306 |
| `AWS_ENDPOINT_URL` | S3 endpoint (use for LocalStack) | - |

## Testing

Run tests with:
```bash
go test ./...
```

Mock generation is documented in [MOCKGEN.md](MOCKGEN.md).

## Integration tests

Integration tests exercise the full stack (app, database, LocalStack). The
test itself is opt-in and will be skipped unless the `INTEGRATION` environment
variable is set to `1`. 

### Test Assets

A test tone MP3 file is available in the `assets/` folder and is used by the
integration tests. If for any reason you need to regenerate it, you can run:

```bash
./scripts/generate_tone.sh ./assets
```

This requires `ffmpeg` to be installed on your system.

### Running Integration Tests

Use the helper script which brings up the Docker services, ensures the test
tone exists (generating it if necessary), runs the integration test, and tears
down the stack:

```bash
./scripts/run-integration.sh
```

If you want to keep the Docker stack running for inspection, set `INTEGRATION_DEBUG=1`:

```bash
INTEGRATION_DEBUG=1 ./scripts/run-integration.sh
```

CI systems should run `./scripts/run-integration.sh` (or the equivalent steps)
to ensure the same environment as local runs.

## Architecture

### Database Schema
The backend uses MySQL to store audio file metadata. The database is automatically initialized via `init.sql` on first run.

<img width="400" src="https://github.com/matttm/spoticli/blob/main/assets/db-arch.png"/>
<img width="400" src="https://github.com/matttm/spoticli/blob/main/assets/db-table.png"/>

### Storage
Audio files are stored in S3 (or LocalStack for local development). The backend provides:
- **Direct access** via presigned URLs
- **Proxy access** for full file downloads
- **Streaming access** with intelligent frame-based chunking

### Services Layer
- **Audio Service**: Handles audio file operations and streaming logic
- **Storage Service**: Manages S3 interactions and presigned URLs
- **Decoder Service**: Parses MP3 frames for efficient streaming
- **Cache Service**: Caches decoded frame boundaries for performance
- **Media Service**: Handles media processing and transcoding

## Deployment

For production deployment instructions, see [DEPLOYMENT.md](DEPLOYMENT.md).

## Additional Resources

- [Postman Collection](spoticli-backend.postman_collection.json) - Import this to test the API
- [README-SIMPLE.md](README-SIMPLE.md) - Simplified documentation
